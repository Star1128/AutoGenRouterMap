"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.executeCoverageOhosTest = void 0;
const path = require("path");
const fs = require("fs");
const util = require("util");
const child_process_1 = require("child_process");
const coverageParser_1 = require("../localTest/coverageParser");
const logPath = '.test/default/intermediates/ohosTest/coverage_data/coverage.log';
const testNameRule = /^[A-Za-z]{1}[\w#,.]*$/;
async function bundleOperate(hdcPath, bundleName, dependenciesPaths, targetHapPath, testHapPath, logger) {
    (0, child_process_1.execSync)(`${hdcPath} uninstall ${bundleName}`, { windowsHide: true });
    for (let item of dependenciesPaths) {
        if (item) {
            if (!fs.existsSync(item)) {
                logger.error(`The path ${item} does not exist. Check whether the hsp package is signed.`);
                return false;
            }
            (0, child_process_1.execSync)(`${hdcPath} install ${item}`, { windowsHide: true });
        }
    }
    if (!fs.existsSync(targetHapPath)) {
        logger.error(`The path ${targetHapPath} does not exist. Check whether the hap/hsp package is signed.`);
        return false;
    }
    if (!fs.existsSync(testHapPath)) {
        logger.error(`The path ${testHapPath} does not exist. Check whether the hap package is signed.`);
        return false;
    }
    const utilCommand = util.promisify(child_process_1.exec);
    const { stdout, stderr } = await utilCommand(`${hdcPath} install ${targetHapPath}`);
    if (stderr) {
        logger.error(stderr);
        return false;
    }
    if (stdout.includes('error: ')) {
        logger.error(stdout);
        return false;
    }
    (0, child_process_1.execSync)(`${hdcPath} install ${testHapPath}`, { windowsHide: true });
    return true;
}
function dirOperate(modulePath) {
    const logDirectory = path.join(modulePath, logPath);
    if (fs.existsSync(logDirectory)) {
        fs.unlinkSync(logDirectory);
    }
    fs.mkdirSync(path.dirname(logDirectory), { recursive: true });
    return logDirectory;
}
/**
 *
 * @param testInstrumentParam
 */
const executeCoverageOhosTest = async (testInstrumentParam) => {
    let { toolchainsPath, projectPath, modulePath, bundleName, coverage, logger, scope, testModuleName, targetHapPath, testHapPath, dependenciesPaths } = testInstrumentParam;
    if (scope !== '' && !testNameRule.test(scope)) {
        logger.error(`scope=${scope} is invalid. Enter a value that contains only digits, letters, underscores (_), and periods (.). Use commas (,) to separate multiple test suites or test cases.`);
        return;
    }
    let hdcPath = toolchainsPath;
    try {
        if (process.platform === 'win32') {
            hdcPath = path.join(toolchainsPath, 'hdc.exe');
        }
        else if (process.platform === 'darwin' || process.platform === 'linux') {
            hdcPath = path.join(toolchainsPath, 'hdc');
        }
        hdcPath = `"${hdcPath}"`;
        (0, child_process_1.execSync)(`cd ${projectPath}`, { windowsHide: true });
        const isContinues = await bundleOperate(hdcPath, bundleName, dependenciesPaths, targetHapPath, testHapPath, logger);
        if (!isContinues) {
            return;
        }
        const logDirectory = dirOperate(modulePath);
        const aaTestCommand = scope
            ? `${hdcPath} shell aa test -b ${bundleName} -m ${testModuleName} -s unittest /ets/testrunner/OpenHarmonyTestRunner -s class ${scope} -s timeout 15000 -s coverage ${coverage}`
            : `${hdcPath} shell aa test -b ${bundleName} -m ${testModuleName} -s unittest /ets/testrunner/OpenHarmonyTestRunner -s timeout 15000 -s coverage ${coverage}`;
        const utilCommand = util.promisify(child_process_1.exec);
        const { stdout, stderr } = await utilCommand(aaTestCommand);
        if (stdout.includes('ExecuteCommand need connect-key?')) {
            logger.error('ExecuteCommand need connect-key?');
            return;
        }
        if (stderr) {
            logger.error('stderr:', stderr);
            return;
        }
        fs.writeFileSync(logDirectory, stdout, { flag: 'a+' });
        await (0, coverageParser_1.parseCoverageData)({
            modulePath: modulePath,
            projectPath: projectPath,
            hdcPath: hdcPath,
            coverage: coverage,
            logger: logger,
            isLocalTest: false
        });
    }
    catch (error) {
        logger.error('executeCoverageOhosTest error: ', error);
    }
};
exports.executeCoverageOhosTest = executeCoverageOhosTest;
