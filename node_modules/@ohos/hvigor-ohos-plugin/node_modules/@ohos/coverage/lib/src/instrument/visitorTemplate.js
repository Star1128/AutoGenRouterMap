"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateVarName = exports.getHashAndNode = exports.addTemplate = exports.getTemplate = exports.coverageTemplate = exports.IS_FA_MODE = exports.LOCAL_TEST_SAVE_PATH = exports.COVERAGE_TYPE = void 0;
const core_1 = require("@babel/core");
const readCoverage_1 = require("./readCoverage");
const crypto_1 = require("crypto");
const constants_1 = require("./constants");
const globalTemplateAlteredFunction = (0, core_1.template)(`
        var Function = (function(){}).constructor;
        var global = (new Function(GLOBAL_COVERAGE_SCOPE))();
`);
const globalTemplateFunction = (0, core_1.template)(`
        var global = (new Function(GLOBAL_COVERAGE_SCOPE))();
`);
const globalTemplateVariable = (0, core_1.template)(`
        var global = GLOBAL_COVERAGE_SCOPE;
`);
exports.COVERAGE_TYPE = 'coverage_type';
exports.LOCAL_TEST_SAVE_PATH = 'local_test_save_path';
exports.IS_FA_MODE = 'is_fa_mode';
const templateStr = `
function COVERAGE_FUNCTION () {
    var nPath = PATH;
    var hash = HASH;
    GLOBAL_COVERAGE_TEMPLATE
    var gcv = GLOBAL_COVERAGE_VAR;
    var coverageData = INITIAL;
    var coverage = global[gcv] || (global[gcv] = {});
    if (!coverage[nPath]) {
        coverage[nPath] = coverageData;
    }

    var actualCoverage = coverage[nPath];
    {
        // @ts-ignore
        COVERAGE_FUNCTION = function () {
            return actualCoverage;
        }
    }
    if (!${exports.IS_FA_MODE}) {
      var savePath = '__savePath__';
      var readPath = '__readPath__'
      if (AbilityDelegatorRegistry.getAbilityDelegator()) {
          global[savePath] = '/data/storage/el2/base/js_coverage.json';
          let uid = Math.floor((AbilityDelegatorRegistry.getAbilityDelegator().getAppContext().applicationInfo.uid)/200000);
          const bundleName = AbilityDelegatorRegistry.getArguments().bundleName;
          global[readPath] = '/data/app/el2/' + uid + '/base/' + bundleName + '/js_coverage.json';
          var testMode = '__testMode__';
          global[testMode] = '${exports.COVERAGE_TYPE}';
      } else {
        console.log('AbilityDelegatorRegistry.getAbilityDelegator is null when coverage data');
      }
  
      if (global[testMode] == 'unitTest') {
        global[savePath] = '${exports.LOCAL_TEST_SAVE_PATH}';
        global[readPath] = '${exports.LOCAL_TEST_SAVE_PATH}';
      }
      return actualCoverage;
    }

    return actualCoverage;
}
`;
// the template to insert at the top of the program.
exports.coverageTemplate = (0, core_1.template)(templateStr, {
    preserveComments: true,
});
function getTemplate(opts, path, T) {
    if (opts.coverageGlobalScopeFunc) {
        if (path.scope.getBinding('Function')) {
            return globalTemplateAlteredFunction({
                GLOBAL_COVERAGE_SCOPE: T.stringLiteral('return ' + opts.coverageGlobalScope),
            });
        }
        else {
            return globalTemplateFunction({
                GLOBAL_COVERAGE_SCOPE: T.stringLiteral('return ' + opts.coverageGlobalScope),
            });
        }
    }
    else {
        return globalTemplateVariable({
            GLOBAL_COVERAGE_SCOPE: opts.coverageGlobalScope,
        });
    }
}
exports.getTemplate = getTemplate;
function addTemplate(path, T, visitorState, countFunction) {
    const importSrc = 'import AbilityDelegatorRegistry from "@ohos.app.ability.abilityDelegatorRegistry";';
    const importAst = (0, readCoverage_1.getAst)(importSrc);
    path.node.body.unshift(T.expressionStatement(T.callExpression(T.identifier(visitorState.varName), [])));
    path.node.body.unshift(countFunction);
    if (path.toString().indexOf('@ohos.app.ability.abilityDelegatorRegistry') == -1) {
        path.node.body.unshift(importAst.program);
    }
}
exports.addTemplate = addTemplate;
function getHashAndNode(coverageData, T) {
    const hashStr = (0, crypto_1.createHash)(constants_1.Encryption.method)
        .update(JSON.stringify(coverageData))
        .digest('hex');
    coverageData.hash = hashStr;
    if (coverageData.inputSourceMap &&
        Object.getPrototypeOf(coverageData.inputSourceMap) !== Object.prototype) {
        coverageData.inputSourceMap = {
            ...coverageData.inputSourceMap,
        };
    }
    const coverageNode = T.valueToNode(coverageData);
    delete coverageData[constants_1.Encryption.key];
    delete coverageData.hash;
    return { hashStr, coverageNode };
}
exports.getHashAndNode = getHashAndNode;
// generate a variable name from hashing the supplied file path
function generateVarName(filename) {
    const hash = (0, crypto_1.createHash)(constants_1.Encryption.method);
    hash.update(filename);
    return 'cov_' + parseInt(hash.digest('hex').substr(0, 12), 16).toString(36);
}
exports.generateVarName = generateVarName;
