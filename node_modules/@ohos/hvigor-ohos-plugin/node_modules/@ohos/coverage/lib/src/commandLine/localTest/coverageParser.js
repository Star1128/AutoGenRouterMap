"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseCoverageData = exports.ENGINE_LOG_ERROR_MESSAGE_LOG = void 0;
const path = require("path");
const fs = require("fs");
const readline = require("readline");
const sourceMap = require("source-map");
const generateReportForHvigorw_1 = require("../../generateReportForHvigorw");
const child_process_1 = require("child_process");
const dataTag = 'OHOS_REPORT_COVERAGE_DATA: ';
const classTag = 'OHOS_REPORT_STATUS: class=';
const statusBaseTag = 'OHOS_REPORT_STATUS: ';
const stackTag = 'OHOS_REPORT_STATUS: stack=';
const streamTag = 'OHOS_REPORT_STATUS: stream=';
const testCaseTag = 'OHOS_REPORT_STATUS: test=';
const statusCodeTag = 'OHOS_REPORT_STATUS_CODE: ';
const resultTag = 'OHOS_REPORT_RESULT: stream=';
const OHOS_REPORT_COVERAGE_PATH = 'OHOS_REPORT_COVERAGE_PATH: ';
exports.ENGINE_LOG_ERROR_MESSAGE_LOG = '[Engine Log]Error message:';
const ENGINE_LOG_TAG = '[Engine Log]';
const ohosRunSourcemapPath = 'build/default/cache/ohosTest/ohosTest@OhosTestCompileArkTS/esmodule/debug/sourceMaps.json';
const localRunSourcemapPath = '.test/default/intermediates/assets/default/ets/sourceMaps.map';
const ohosCoverageSourcemapPath = '.test/default/intermediates/ohosTest/coverage_sourcemap/ohosTestSourceMap.map';
const localCoverageSourcemapPath = '.test/default/intermediates/test/coverage_sourcemap/unitTestSourceMap.map';
const sourceMapNotInitialized = 'SourceMap is not initialized yet';
let className = '';
let testCaseName = '';
let isStackStatus = false;
let statusBaseIndex = -1;
let logArr = [];
let engineErrorStart = false;
let isSourceMapInitialized = true;
let isLocalTest = true;
let isCoverage = true;
let coverageSourceMapJson;
let sdkSourceMapJson;
function dirOperate(coverageData, coverageDirectory, Logger) {
    if (coverageData) {
        if (fs.existsSync(coverageDirectory)) {
            fs.unlinkSync(coverageDirectory);
        }
        fs.writeFileSync(coverageDirectory, coverageData, 'utf8');
        Logger.info('coverage data from call back');
    }
    else {
        Logger.info('coverage data from file');
    }
}
const parseCoverageData = async (coverageParserParam) => {
    const coverageType = coverageParserParam.isLocalTest ? 'test' : 'ohosTest';
    isLocalTest = coverageParserParam.isLocalTest;
    const logPath = `.test/default/intermediates/${coverageType}/coverage_data/coverage.log`;
    const coveragePath = `.test/default/intermediates/${coverageType}/coverage_data/js_coverage.json`;
    const testResultPath = `.test/default/intermediates/${coverageType}/coverage_data/test_result.txt`;
    const Logger = coverageParserParam.logger;
    const modulePath = coverageParserParam.modulePath;
    const projectPath = coverageParserParam.projectPath;
    const logDirectory = path.join(modulePath, logPath);
    const coverageDirectory = path.join(modulePath, coveragePath);
    const testResultDirectory = path.join(modulePath, testResultPath);
    const sourceMapPathStr = coverageType === 'test' ? localRunSourcemapPath : ohosRunSourcemapPath;
    const sourceMapPath = path.join(modulePath, sourceMapPathStr);
    let sourceMapFile = fs.readFileSync(sourceMapPath, 'utf-8');
    sdkSourceMapJson = JSON.parse(sourceMapFile);
    isCoverage = coverageParserParam.coverage;
    if (isCoverage) {
        const coverageSourceMapPathStr = coverageType === 'test' ? localCoverageSourcemapPath : ohosCoverageSourcemapPath;
        const coverageSourceMapPath = path.join(modulePath, coverageSourceMapPathStr);
        let coverageSourceMapFile = fs.readFileSync(coverageSourceMapPath, 'utf-8');
        coverageSourceMapJson = JSON.parse('{' + coverageSourceMapFile.substring(0, coverageSourceMapFile.length - 1) + '}');
    }
    const hdcPath = coverageParserParam.hdcPath;
    resetStatus();
    const rl = readline.createInterface({
        input: fs.createReadStream(logDirectory),
        output: process.stdout,
        terminal: false,
    });
    if (fs.existsSync(testResultDirectory)) {
        fs.unlinkSync(testResultDirectory);
    }
    let coverageData = '';
    for await (const line of rl) {
        logArr.push(line);
    }
    for await (const [idx, line] of logArr.entries()) {
        if (await isEngineError(line, modulePath, coverageType, Logger)) {
            continue;
        }
        if (await logStack({ line, logger: Logger, filePath: testResultDirectory, modulePath, coverageType, idx, isCoverage })
            || logClassAndTestSuite(line, testResultDirectory)
            || logTestResult(line, testResultDirectory)) {
            continue;
        }
        let dataIndex = line.indexOf(dataTag);
        if (dataIndex != -1) {
            let data = line.substring(dataIndex + dataTag.length);
            coverageData = coverageData + data;
            continue;
        }
        if (coverageType === 'ohosTest' && line.indexOf(OHOS_REPORT_COVERAGE_PATH) != -1) {
            coverageData = '';
            let coverageIndex = line.indexOf(OHOS_REPORT_COVERAGE_PATH);
            let pathInDevice = line.substring(coverageIndex + OHOS_REPORT_COVERAGE_PATH.length);
            (0, child_process_1.execSync)(`${hdcPath} file recv ${pathInDevice} ${coverageDirectory}`, { windowsHide: true });
            continue;
        }
    }
    logArr = [];
    dirOperate(coverageData, coverageDirectory, Logger);
    await generateReport(isCoverage, modulePath, coverageDirectory, projectPath, coverageType);
};
exports.parseCoverageData = parseCoverageData;
async function logStack(logStackParams) {
    const { line, logger, filePath, modulePath, coverageType, idx } = logStackParams;
    let tempStatusBaseIndex = line.indexOf(statusBaseTag);
    if (tempStatusBaseIndex != -1) {
        isStackStatus = line.substring(tempStatusBaseIndex + statusBaseTag.length).startsWith('stack=');
        statusBaseIndex = tempStatusBaseIndex;
    }
    let stackIndex = line.indexOf(stackTag);
    if (stackIndex != -1) {
        let streamLog = '';
        for (let i = idx; i < logArr.length; i++) {
            let streamIndex = logArr[i].indexOf(streamTag);
            if (streamIndex !== -1) {
                streamLog = logArr[i].substring(streamIndex + streamTag.length);
                break;
            }
        }
        let stackContent = line.substring(stackIndex + stackTag.length);
        if (stackContent.trim().includes(sourceMapNotInitialized.trim())) {
            isSourceMapInitialized = false;
        }
        let errInfo1 = await identifyError(modulePath, stackContent, coverageType);
        logger.error(streamLog);
        if (errInfo1 != '') {
            logger.error(errInfo1);
        }
        isStackStatus = true;
        fs.appendFileSync(filePath, streamLog + '\n' + errInfo1 + '\n', 'utf8');
        return true;
    }
    if (isStackStatus) {
        let errInfo2 = await identifyError(modulePath, line.substring(statusBaseIndex), coverageType);
        if (errInfo2 != '') {
            logger.error(errInfo2);
        }
        fs.appendFileSync(filePath, errInfo2 + '\n', 'utf8');
        return true;
    }
    else {
        isSourceMapInitialized = true;
    }
    return false;
}
async function isEngineError(line, modulePath, coverageType, logger) {
    if (line.indexOf(exports.ENGINE_LOG_ERROR_MESSAGE_LOG) > -1) {
        engineErrorStart = true;
    }
    if (engineErrorStart && line.indexOf(ENGINE_LOG_TAG) > -1) {
        let stackContent = line.substring(line.lastIndexOf(ENGINE_LOG_TAG) + ENGINE_LOG_TAG.length);
        let errInfo = await identifyError(modulePath, stackContent, coverageType);
        logger.error(errInfo);
        return true;
    }
    if (engineErrorStart && line.indexOf(ENGINE_LOG_TAG) < 0) {
        engineErrorStart = false;
    }
    return false;
}
function logClassAndTestSuite(line, filePath) {
    let classIndex = line.indexOf(classTag);
    if (classIndex != -1) {
        let tempTlassName = line.substring(classIndex + classTag.length);
        if (tempTlassName != className) {
            className = tempTlassName;
            fs.appendFileSync(filePath, `class=${className}\n`, 'utf8');
        }
        return true;
    }
    let testCaseIndex = line.indexOf(testCaseTag);
    if (testCaseIndex != -1) {
        let tempTestCaseName = line.substring(testCaseIndex + testCaseTag.length);
        if (tempTestCaseName != testCaseName) {
            testCaseName = tempTestCaseName;
            fs.appendFileSync(filePath, `test=${testCaseName}\n`, 'utf8');
        }
        return true;
    }
    return false;
}
function logTestResult(line, filePath) {
    let resultIndex = line.indexOf(resultTag);
    if (resultIndex != -1) {
        let resultContent = line.substring(resultIndex + resultTag.length);
        fs.appendFileSync(filePath, resultContent + '\n', 'utf8');
        return true;
    }
    let statusCodeIndex = line.indexOf(statusCodeTag);
    if (statusCodeIndex != -1) {
        let statusCode = Number.parseInt(line.substring(statusCodeIndex + statusCodeTag.length));
        switch (statusCode) {
            case 0:
                fs.appendFileSync(filePath, 'result=Success\n', 'utf8');
                break;
            case -1:
                fs.appendFileSync(filePath, 'result=Error\n', 'utf8');
                break;
            case -2:
                fs.appendFileSync(filePath, 'result=Failure\n', 'utf8');
                break;
            case -3:
                fs.appendFileSync(filePath, 'result=Ignore\n', 'utf8');
                break;
        }
        return true;
    }
    return false;
}
function resetStatus() {
    className = '';
    testCaseName = '';
    isStackStatus = false;
    statusBaseIndex = -1;
}
async function generateReport(isCoverage, modulePath, coverageDirectory, projectPath, coverageType) {
    if (!isCoverage) {
        return;
    }
    const initCoveragePath = `${modulePath}/.test/default/intermediates/${coverageType}/init_coverage.json`;
    if (!fs.existsSync(initCoveragePath)) {
        return;
    }
    const reportPath = `${modulePath}/.test/default/outputs/${coverageType}/reports`;
    let coverPath = fs.existsSync(coverageDirectory) ? `${coverageDirectory}#${initCoveragePath}` : initCoveragePath;
    await (0, generateReportForHvigorw_1.generateReportForHvigorw)(projectPath, reportPath, coverPath);
}
const identifyError = async (modulePath, stackContent, coverageType) => {
    const reg = / {4}at \w+? \(.+?:\d+?:\d+?\)/;
    if (!reg.test(stackContent)) {
        return '';
    }
    const stackArr = stackContent.split(':');
    const stackInitPath = stackArr[0];
    const line = Number(stackArr[1]);
    if (line == 0) {
        return '';
    }
    const column = Number(stackArr[2].substring(0, stackArr[2].length - 1));
    let stackPath = stackInitPath.split('(')[1];
    let sourceMapJson = modulePath + coverageType;
    sourceMapJson = sdkSourceMapJson;
    let targetKey = '';
    for (let sourcemapKey of Object.keys(sourceMapJson)) {
        if (sourcemapKey.replace(/\\/g, '/').includes(stackPath.replace(/\.(ets|ts|js)/g, ''))) {
            targetKey = sourcemapKey;
            break;
        }
    }
    if (!targetKey) {
        return stackContent;
    }
    const targetArr = sourceMapJson[targetKey].sources[0];
    if (isCoverage) {
        sourceMapJson = coverageSourceMapJson;
        targetKey = targetArr;
    }
    if (isSourceMapInitialized && !isCoverage && !isLocalTest) {
        return `${stackInitPath.split('(')[0]}(${targetArr}:${line}:${column})`;
    }
    if (sourceMapJson[targetKey] === undefined) {
        return `${stackInitPath.split('(')[0]}(${targetArr}:${line}:${column})`;
    }
    const consumer = await new sourceMap.SourceMapConsumer(sourceMapJson[targetKey]);
    const originalPosition = consumer.originalPositionFor({
        line: line,
        column: column,
    });
    let newLine = originalPosition.line;
    let newColumn = originalPosition.column;
    if (newColumn) {
        if (isLocalTest) {
            newColumn += 1;
        }
        else if (isCoverage) {
            newColumn += 1;
        }
    }
    else {
        newColumn = column;
    }
    return `${stackInitPath.split('(')[0]}(${targetArr}:${newLine}:${newColumn})`;
};
