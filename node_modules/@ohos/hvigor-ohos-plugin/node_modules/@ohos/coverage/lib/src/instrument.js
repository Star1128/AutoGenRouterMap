"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.instrument = void 0;
const fs = require("fs");
const path = require("path");
const log4js = require("log4js");
const os = require("os");
const filterKey = 'use concurrent';
const filterIstanbulKey = '/* instrument ignore next */';
const ignorefile = ' // instrument ignore file';
const useSendable = '"use sendable";';
const logger = log4js.getLogger();
const visitorTemplate_1 = require("../src/instrument/visitorTemplate");
const index_1 = require("./instrument/index");
const json5_1 = require("json5");
const ohosTest = 'ohosTest';
const srcOhosTest = `src${path.sep}ohosTest`;
const srcMock = `src${path.sep}mock`;
const entryTest = '.test';
const unitTest = 'unitTest';
const ohosTestSourcePath = '.test/default/intermediates/ohosTest/source';
const unitTestSourcePath = '.test/default/intermediates/test/source';
const ohosTestInstrumentPath = '.test/default/intermediates/ohosTest/instrument';
const unitTestInstrumentPath = '.test/default/intermediates/test/instrument';
const ohosTestInitPath = '.test/default/intermediates/ohosTest/init_coverage.json';
const unitTestInitPath = '.test/default/intermediates/test/init_coverage.json';
const ohosTestSourceMapPath = '.test/default/intermediates/ohosTest/coverage_sourcemap';
const unitTestSourceMapPath = '.test/default/intermediates/test/coverage_sourcemap';
const localTestCoveragePath = '.test/default/intermediates/test/coverage_data/js_coverage.json';
const ohosModule = 'oh_modules';
const test = `src${path.sep}test`;
const etsSuffix = '.ets';
const tsSuffix = '.ts';
const jsSuffix = '.js';
const observeKey = 'var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {';
const instrumenter = (0, index_1.createInstrumenter)({
    compact: false,
    esModules: true
});
const getTargetPath = (coverageType, sourcePath, modulePath, instrumentPath) => {
    if (coverageType.includes(ohosTest)) {
        sourcePath = path.join(modulePath, ohosTestSourcePath);
        instrumentPath = path.join(modulePath, ohosTestInstrumentPath);
    }
    else if (coverageType.includes(unitTest)) {
        sourcePath = path.join(modulePath, unitTestSourcePath);
        instrumentPath = path.join(modulePath, unitTestInstrumentPath);
    }
    return { sourcePath, instrumentPath };
};
/**
 * 功能：代码插桩
 * @param {string} projectPath 插桩文件路径
 * @param {string} modulePath 模块路径
 * @param {string} source 源码
 * @param {sourceMap} sourceMap 转换生成js文件对应的sourceMap文件
 * @param {testFrameworkParam} 跑测试用例涉及的参数对象
 * @returns {string}
 */
const instrument = (instrumentParam) => {
    let { projectPath, modulePath, source, sourceMap, testFrameworkParam, id, isFaMode } = instrumentParam;
    try {
        // map文件中保存的文件路径
        const mapFilePath = sourceMap.sources[0];
        const mapFileDirPath = path.dirname(mapFilePath);
        let coverageType = testFrameworkParam.testMode;
        if (modulePath.indexOf(srcOhosTest) !== -1) {
            throw new Error('enter instrument ohosTest.');
        }
        if (mapFileDirPath.includes(ohosModule)) {
            return { source, id };
        }
        let sourceMapPath = coverageType == ohosTest
            ? path.join(modulePath, ohosTestSourceMapPath, 'ohosTestSourceMap.map')
            : path.join(modulePath, unitTestSourceMapPath, 'unitTestSourceMap.map');
        if (!fs.existsSync(sourceMapPath)) {
            fs.mkdirSync(path.dirname(sourceMapPath), { recursive: true });
        }
        let sourcePath = '';
        let instrumentPath = '';
        const pathObj = getTargetPath(coverageType, sourcePath, modulePath, instrumentPath);
        sourcePath = pathObj.sourcePath;
        instrumentPath = pathObj.instrumentPath;
        if (mapFileDirPath.includes(srcOhosTest) || mapFileDirPath.includes(test)
            || mapFileDirPath.includes(entryTest) || mapFileDirPath.includes(srcMock)) {
            const [, noInstrumentSourcePath] = mapFilePath.split(projectPath + path.sep);
            fs.appendFileSync(sourceMapPath, '\"' + noInstrumentSourcePath.replace(/\\/g, '/') + '\":' + JSON.stringify(sourceMap) + ',');
            return { source, id };
        }
        let paramMap = {
            'projectPath': projectPath,
            'modulePath': modulePath,
            'sourcePath': sourcePath,
            'instrumentPath': instrumentPath,
            'mapFileDirPath': mapFileDirPath,
            'mapFilePath': mapFilePath,
            'sourceMapPath': sourceMapPath,
            'coverageMode': testFrameworkParam.coverageMode
        };
        source = instrumentPart2(isFaMode, source, sourceMap, coverageType, paramMap);
        source = deleteMap(source);
    }
    catch (err) {
        logger.error('instrument failed, error:' + err);
    }
    return { source, id };
};
exports.instrument = instrument;
function instrumentPart2(isFaMode, source, sourceMap, coverageType, paramMap) {
    if (source.includes(useSendable)) {
        source = instrumentFilterSendable(source);
    }
    // 拼接.test文件夹下插桩文件和源文件的文件路径,路径和模块下的相对文件路径保持一致
    let projectPath = paramMap['projectPath'].concat(path.sep);
    let fileRelPath = paramMap['mapFileDirPath'].replace(projectPath, '');
    const sourceFilePath = paramMap['mapFilePath']
        .replace(paramMap['mapFileDirPath'], path.resolve(paramMap['sourcePath'], fileRelPath))
        .replace(etsSuffix, jsSuffix)
        .replace(tsSuffix, jsSuffix);
    const instrumentFilePath = paramMap['mapFilePath']
        .replace(paramMap['mapFileDirPath'], path.resolve(paramMap['instrumentPath'], fileRelPath))
        .replace(etsSuffix, jsSuffix)
        .replace(tsSuffix, jsSuffix);
    // 跳过插桩@concurrent注解标识的方法
    if (source.search(filterKey) != -1 || source.search(observeKey) != -1) {
        source = instrumentFilter(source);
    }
    if (path.dirname(sourceFilePath) != path.dirname(instrumentFilePath)) {
        const [, sourcePath] = paramMap['mapFilePath'].split(projectPath);
        sourceMap.sources[0] = sourcePath;
        // 在模块.test下创建临时文件夹，保存插件文件和源文件
        fsTransform(sourceFilePath, instrumentFilePath, paramMap['sourceMapPath'], source, sourceMap, sourcePath);
        // 将插桩后的文件内容更新到内存中
        source = fs.readFileSync(instrumentFilePath, 'utf-8');
        if (paramMap.coverageMode == 'black' && coverageType.includes('ohosTest')) {
            const abilityName = getTargetAbility(paramMap['modulePath']);
            source = abilityName ? saveCoverageToDevice(instrumentFilePath, source, abilityName) : source;
            if (instrumentFilePath.includes(`${abilityName}.js`)) {
                logger.log('modulePath:', paramMap['modulePath']);
                logger.log('coverageType:', coverageType);
            }
        }
        if (source.indexOf('// instrument ignore file') === -1 && source.indexOf('/* instrument ignore file */') === -1) {
            initCoverageData(source, paramMap['modulePath'], coverageType);
        }
        source = source.replace(`if (!${visitorTemplate_1.IS_FA_MODE}) {`, `if (!${isFaMode}) {`);
        source = source.replace(`global[testMode] = '${visitorTemplate_1.COVERAGE_TYPE}';`, `global[testMode] = '${coverageType}';`);
        let savePath = path.join(paramMap['modulePath'], localTestCoveragePath).replace(/\\/g, '\\\\');
        source = source.replace(`global[savePath] = '${visitorTemplate_1.LOCAL_TEST_SAVE_PATH}';`, `global[savePath] = '${savePath}';`);
        source = source.replace(`global[readPath] = '${visitorTemplate_1.LOCAL_TEST_SAVE_PATH}';`, `global[readPath] = '${savePath}';`);
        fs.unlinkSync(instrumentFilePath);
        fs.writeFileSync(instrumentFilePath, source);
    }
    return source;
}
/**
 * 功能：在模块.test下创建临时文件夹，保存插件文件和源文件
 * @param sourceFilePath
 * @param instrumentFilePath
 * @param sourceMapPath
 * @param source
 * @param sourceMap
 */
function fsTransform(sourceFilePath, instrumentFilePath, sourceMapPath, source, sourceMap, sourcePath) {
    // 在模块.test下创建临时文件夹，保存插件文件和源文件
    fs.mkdirSync(path.dirname(sourceFilePath), { recursive: true });
    fs.mkdirSync(path.dirname(instrumentFilePath), { recursive: true });
    fs.writeFileSync(sourceFilePath, source);
    const instrumentSource = instrumenter.instrumentSync(source, sourceFilePath, sourceMap);
    let lastSourceMap = instrumenter.lastSourceMap();
    fs.appendFileSync(sourceMapPath, '\"' + sourcePath.replace(/\\/g, '/') + '\":' + JSON.stringify(lastSourceMap) + ',');
    fs.writeFileSync(instrumentFilePath, instrumentSource);
    fs.writeFileSync(`${sourceFilePath}.map`, JSON.stringify(sourceMap));
}
/**
 * 功能：对源文件进行过滤，如果方法中包含use concurrent则将在此方法加上nyc注释跳过插桩
 * @param {string} source js文件内容
 * @returns {string}
 */
function instrumentFilter(source) {
    let lineData = source.split(os.EOL);
    let length = lineData.length;
    let filterSource = '';
    for (let i = 0; i < length; i++) {
        if (lineData[i].includes(filterKey) && i - 1 >= 0) {
            let previousOneLine = lineData[i - 1];
            lineData[i - 1] = filterIstanbulKey + os.EOL + previousOneLine;
        }
        if (lineData[i].includes(observeKey)) {
            lineData[i] = filterIstanbulKey + os.EOL + lineData[i];
        }
    }
    for (let j = 0; j < lineData.length; j++) {
        filterSource = filterSource.concat(lineData[j]).concat(os.EOL);
    }
    return filterSource;
}
/**
 * 功能：对源文件进行过滤，如果方法中包含Sendable注解，则将注解删除，并加上instrument ignore file注释
 * @param {string} source js文件内容
 * @returns {string}
 */
function instrumentFilterSendable(source) {
    source = source.replace('collections.Array', 'Array');
    source = source.replace('collections.Map', 'Map');
    source = source.replace('collections.Set', 'Set');
    let lineData = source.split(os.EOL);
    let length = lineData.length;
    let filterSource = '';
    let classStr = '';
    let classKey = -1;
    for (let i = 0; i < length; i++) {
        if (lineData[i].includes('class ')) {
            classStr = ignorefile + os.EOL + lineData[i];
            classKey = i;
        }
        if (lineData[i].includes(useSendable)) {
            lineData[i] = lineData[i].replace('"use sendable";', '');
            if (classKey >= 0) {
                lineData[classKey] = classStr;
                classKey = -1;
            }
        }
    }
    for (let j = 0; j < lineData.length; j++) {
        filterSource = filterSource.concat(lineData[j]).concat(os.EOL);
    }
    return filterSource;
}
/**
 * 初始化覆盖率数据
 *
 * @param source 插桩后的源码
 * @param modulePath 模块路径
 * @param coverageType ohosTest/unitTest
 */
function initCoverageData(source, modulePath, coverageType) {
    const coverageDataIdentifies = 'coverageData = ';
    // 获取插装源码文件中的覆盖率数据在文件中的起止位置
    const index = source.indexOf(coverageDataIdentifies);
    const coverageDataStartIndex = index + coverageDataIdentifies.length;
    const coverageDataEndIndex = source.indexOf('var coverage =');
    let tempSource = source.substring(coverageDataStartIndex, coverageDataEndIndex);
    let tempIndex = tempSource.indexOf('\n  };');
    let sourceResult = tempSource.substring(0, tempIndex).concat(os.EOL).concat('  }');
    // 匹配json中未带双引号的key
    sourceResult = sourceResult.replace(/(\w+)\s*:\s/g, '\"$1\": ');
    sourceResult = sourceResult.replace(/"sourcesContent":.*/g, '\"sourcesContent\":[],');
    const sourceJson = JSON.parse(sourceResult);
    const sourcePath = sourceJson.path;
    const sourceKey = sourcePath.replace(/\\/g, '\\\\');
    let initCoveragePath = '';
    if (coverageType.includes(ohosTest)) {
        initCoveragePath = path.join(modulePath, ohosTestInitPath);
    }
    else if (coverageType.includes(unitTest)) {
        initCoveragePath = path.join(modulePath, unitTestInitPath);
    }
    let formatSource = '';
    // 拼接成可merge的json格式
    mergeJson(initCoveragePath, formatSource, sourceKey, sourceResult);
}
function mergeJson(initCoveragePath, formatSource, sourceKey, sourceResult) {
    if (fs.existsSync(initCoveragePath)) {
        formatSource = `,${os.EOL}"${sourceKey}":${sourceResult}`;
    }
    else {
        formatSource = `"${sourceKey}":${sourceResult}`;
    }
    fs.appendFileSync(initCoveragePath, formatSource);
}
/**
 * 功能：对黑盒测试的主ability销毁方法中将覆盖率数据写入设备
 * @param instrumentFilePath 插桩路径
 * @param source 源码或者插桩代码
 * @param abilityName 主ability名称
 * @returns
 */
function saveCoverageToDevice(instrumentFilePath, source, abilityName) {
    if (abilityName && instrumentFilePath.includes(`${abilityName}.js`)) {
        logger.log('Ability start onDestroy', instrumentFilePath);
        let flagStr = 'onDestroy() {\n';
        let covIndex = source.indexOf('onDestroy() {\n');
        let filePath = `    let filePath = this.context.cacheDir + \`/black_test_result_\${new Date().getTime()}.json\`;`;
        let file = '    let file = fileIo.openSync(filePath, fileIo.OpenMode.READ_WRITE | fileIo.OpenMode.CREATE);';
        let strJson = '    const strJson = JSON.stringify(globalThis.__coverage__);';
        let writeLen = '    let writeLen = fileIo.writeSync(file.fd, strJson);';
        let consoleInfo = '    console.info(\'write data to file succeed and size is :\' + writeLen);';
        let closeFile = '    fileIo.closeSync(file);';
        let fileIoImport = 'import fileIo from \'@ohos.file.fs\';';
        source = fileIoImport.concat('\n')
            .concat(source.substring(0, covIndex + flagStr.length))
            .concat('\n')
            .concat(filePath)
            .concat('\n')
            .concat(file)
            .concat('\n')
            .concat(strJson)
            .concat('\n')
            .concat(writeLen)
            .concat('\n')
            .concat(consoleInfo)
            .concat('\n')
            .concat(closeFile)
            .concat('\n')
            .concat(source.substring(covIndex + flagStr.length));
        logger.log('instrumentFilePath is :', instrumentFilePath);
        fs.unlinkSync(instrumentFilePath);
        fs.mkdirSync(path.dirname(instrumentFilePath), { recursive: true });
        fs.writeFileSync(instrumentFilePath, source);
    }
    return source;
}
/**
 * 功能：获取ability名称
 * @param ability
 * @param abilityName
 * @returns
 */
function getAbilityName(ability, abilityName) {
    for (let skill of ability.skills) {
        if (skill.entities.includes('entity.system.home') && skill.actions.includes('action.system.home')) {
            abilityName = ability.name;
            break;
        }
    }
    return abilityName;
}
/**
 * 功能：获取module.json5中主ability名称
 * @param modulePath 模块路径
 * @returns 目标ability名称
 */
function getTargetAbility(modulePath) {
    const moduleJson5Path = `${modulePath}/src/main/module.json5`;
    const moduleContent = fs.readFileSync(moduleJson5Path, 'utf-8');
    const moduleJson = (0, json5_1.parse)(moduleContent);
    let abilityName = '';
    if (moduleJson.module.abilities) {
        for (let ability of moduleJson.module.abilities) {
            if (ability.skills) {
                abilityName = getAbilityName(ability, abilityName);
                break;
            }
        }
    }
    if (!abilityName) {
        abilityName = moduleJson.module.mainElement ? moduleJson.module.mainElement : '';
    }
    return abilityName;
}
/**
 * 功能：删除source部分数据，减少内存负担
 * @param source source
 * @returns source
 */
function deleteMap(source) {
    const splitStr = 'statementMap: {\n';
    const splitIdx = source.indexOf(splitStr);
    const lastStr = 's: {\n';
    const lastIdx = source.indexOf(lastStr);
    const str = source.substring(splitIdx, lastIdx - 5);
    const length = getStringLineCount(str);
    source = source
        .substring(0, splitIdx)
        .concat(Array(length).fill('\n').join(''))
        .concat(source.substring(lastIdx, source.length));
    return source;
}
/**
 * 功能：获得字符串的行数
 * @param str string
 * @returns number 行数
 */
function getStringLineCount(str) {
    return str.split('\n').length;
}
