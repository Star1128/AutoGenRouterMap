"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.executeCoverageTest = void 0;
const path = require("path");
const fs = require("fs");
const node_child_process_1 = require("node:child_process");
const string_decoder_1 = require("string_decoder");
const coverageParser_1 = require("./coverageParser");
const portutil_1 = require("./portutil");
const decoder = new string_decoder_1.StringDecoder('utf8');
const abcDirRelative = '.test/default/intermediates/assets/default/ets';
const resoucrceDirRelative = '.test/default/intermediates/res/default';
const logPathRelative = '.test/default/intermediates/test/coverage_data/coverage.log';
const phonePathRelative = '.test/testability/phoneSettingConfig_Phone.json';
const importHsp = 'Importing shared package in the Previewer';
const loaderPathRelative = '/.test/default/intermediates/loader/default/loader.json';
const getSpawnChild = (previewerFullDir, abcDir, phoneConfigPath, resourceDirectory, loaderPath, portNum) => {
    let previewerPath = previewerFullDir;
    if (process.platform === 'win32') {
        previewerPath = path.join(previewerFullDir, 'Previewer.exe');
    }
    else if (process.platform === 'darwin' || process.platform === 'linux') {
        previewerPath = path.join(previewerFullDir, 'Previewer');
    }
    const child = (0, node_child_process_1.spawn)(previewerPath, [
        '-refresh', 'region',
        '-projectID', '743055776',
        '-ts', 'trace_7947_commandPipe',
        '-j', abcDir,
        '-s', 'phone_1702972840143_1',
        '-cpm', 'false',
        '-device', 'phone',
        '-shape', 'rect',
        '-sd', '480',
        '-or', '1080', '2340',
        '-cr', '1080', '2340',
        '-f', phoneConfigPath,
        '-n', 'entry',
        '-av', 'ACE_2_0',
        '-p', '15038',
        '-url', '../../../.test/testability/pages/Index',
        '-pages', 'main_pages',
        '-arp', resourceDirectory,
        '-pm', 'Stage',
        '-l', 'zh_CN',
        '-cm', 'light',
        '-o', 'portrait',
        '-ljPath', loaderPath,
        '-lws', portNum,
    ], { windowsHide: true, cwd: previewerFullDir });
    return child;
};
const portSet = new Set();
const executeCoverageTest = async (testPreviewerParam) => {
    const sdkApiPath = testPreviewerParam.sdkApiPath;
    const modulePath = testPreviewerParam.modulePath;
    const Logger = testPreviewerParam.logger;
    let previewerFullDir = path.join(sdkApiPath, '/common/bin');
    const abcDir = path.join(modulePath, abcDirRelative);
    const resourceDir = path.join(modulePath, resoucrceDirRelative);
    const logPath = path.join(modulePath, logPathRelative);
    const phoneConfigPath = path.join(modulePath, phonePathRelative);
    const loaderPath = path.join(modulePath, loaderPathRelative);
    if (fs.existsSync(logPath)) {
        fs.unlinkSync(logPath);
    }
    if (!fs.existsSync(logPath)) {
        fs.mkdirSync(path.dirname(logPath), { recursive: true });
    }
    const portNum = (0, portutil_1.findPort)(40000, 0, Logger, portSet);
    if (portNum < 0) {
        Logger.error('No port available');
        return new Promise((resolve) => {
            resolve();
        });
    }
    let previewPromise = new Promise((resolve, reject) => {
        const child = getSpawnChild(previewerFullDir, abcDir, phoneConfigPath, resourceDir, loaderPath, `${portNum}`);
        child.on('close', () => {
            portSet.delete(portNum);
        });
        child.stdout.on('data', (data) => {
            let previewData = decoder.write(data);
            try {
                fs.writeFileSync(logPath, data, { flag: 'a+' });
                // file written successfully
                identifyImportHsp(previewData);
            }
            catch (err) {
                reject(err);
            }
            if (isShouldKillPreviewer(data)) {
                child.kill();
                (0, coverageParser_1.parseCoverageData)({
                    modulePath: modulePath,
                    projectPath: testPreviewerParam.projectPath,
                    hdcPath: testPreviewerParam.sdkApiPath,
                    coverage: testPreviewerParam.coverage,
                    logger: Logger,
                    isLocalTest: true
                })
                    .then(() => {
                    resolve();
                })
                    .catch(reject);
            }
        });
    });
    return previewPromise;
};
exports.executeCoverageTest = executeCoverageTest;
function isShouldKillPreviewer(data) {
    if (data.indexOf(coverageParser_1.ENGINE_LOG_ERROR_MESSAGE_LOG) > -1) {
        return true;
    }
    if (data.indexOf('The AbilityDelegator.finishTest') > -1) {
        return true;
    }
    return false;
}
const identifyImportHsp = (line) => {
    let classIndex = line.indexOf(importHsp);
    if (classIndex != -1) {
        throw new Error('Importing shared package is not supported');
    }
};
