"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.runTaskFromQueue=void 0;const process_1=__importDefault(require("process")),noop_js_1=require("../../../../common/util/noop.js"),hvigor_log_js_1=require("../../../log/hvigor-log.js"),task_util_js_1=require("../../../util/task-util.js"),time_util_js_1=require("../../../util/time-util.js"),incremental_task_executor_js_1=require("../../core/incremental-task-executor.js"),event_id_options_js_1=require("../../lifecycle/event/event-id-options.js"),hvigor_process_js_1=require("../../lifecycle/hvigor-process.js"),task_module_util_js_1=require("../util/task-module-util.js"),task_path_util_js_1=require("../util/task-path-util.js"),task_control_center_listener_js_1=require("./listener/task-control-center-listener.js"),task_control_center_js_1=require("./task-control-center.js"),task_execute_status_js_1=require("./task-execute-status.js"),_log=hvigor_log_js_1.HvigorLogger.getLogger("task-runner"),runTaskFromQueue=async()=>{const e=task_control_center_js_1.taskControlCenter.popRunnableTask();if(!e)return void(task_control_center_js_1.taskControlCenter.allTasksHasExecuted()&&hvigor_process_js_1.hvigorProcess.emit(event_id_options_js_1.HVIGOR_PROCESS_EVENT_ID.FINISHED));const t=(0,task_module_util_js_1.getModuleFromTaskPath)(e);if(!t){const t=`Cannot find module from task ${e}!`;return _log.error(t),void hvigor_process_js_1.hvigorProcess.emit(event_id_options_js_1.HVIGOR_PROCESS_EVENT_ID.FAILED,t)}const s=(0,task_path_util_js_1.getTaskNameFromTaskPath)(e),r=t.getTaskContainer().findTask(s);if(void 0===r){const t=`Cannot find task ${e}!`;return _log.error(t),void hvigor_process_js_1.hvigorProcess.emit(event_id_options_js_1.HVIGOR_PROCESS_EVENT_ID.FAILED,t)}hvigor_process_js_1.hvigorProcess.hasTaskDone=!0,r.taskExecutedStatus.setState(task_execute_status_js_1.TASK_EXECUTE_STATUS.PENDING);if(!await executeOneTask(r))return;const o=!!r.pendingPromises.get().length;if(r.getEnabled()){if(r.taskExecutedStatus.isUpToDate())(0,task_control_center_listener_js_1.onTaskUpToDated)(r);else if(!o){const e=process_1.default.hrtime(hvigor_process_js_1.hvigorProcess.taskBeginTime),t=(0,time_util_js_1.formatTime)(e);_log.debug(`runTaskFromQueue task cost before running: ${t}`),(0,task_control_center_listener_js_1.onTaskFinished)(r)}}else(0,task_control_center_listener_js_1.onTaskDisabled)(r);o&&handleTaskPendingPromises(r),await(0,exports.runTaskFromQueue)()};exports.runTaskFromQueue=runTaskFromQueue;const handleTaskPendingPromises=e=>{const t=e.pendingPromises.get();e.pendingPromises.clear(),t.forEach((t=>{t.catch((t=>{(0,task_control_center_listener_js_1.onWorkFailed)(e,t)}))})),Promise.all(t).then((()=>{(0,task_control_center_listener_js_1.onTaskFinished)(e),(0,exports.runTaskFromQueue)().catch((e=>{e instanceof Error&&hvigor_process_js_1.hvigorProcess.error(e)}))})).catch(noop_js_1.noop)};async function executeOneTask(e){try{const t=process_1.default.memoryUsage();if(e.taskExecutedStatus.setState(task_execute_status_js_1.TASK_EXECUTE_STATUS.RUNNING),e.durationEvent.start(),task_control_center_js_1.taskControlCenter.pushRunningTask(e),!e.getEnabled())return e.taskExecutedStatus.setState(task_execute_status_js_1.TASK_EXECUTE_STATUS.END),!0;_log.debug(`Executing task :${e.getPath()}`),(0,task_util_js_1.isIncrementalTask)(e)?await(0,incremental_task_executor_js_1.doIncrementalTask)(e):await e.execute(),e.taskExecutedStatus.setState(task_execute_status_js_1.TASK_EXECUTE_STATUS.END);const s=process_1.default.memoryUsage();_log.debug(e.getNode().getName(),":",e.getName(),"cost memory",(s.heapUsed-t.heapUsed)/1024/1024);const r=(0,time_util_js_1.formatTimeToNumber)(e.taskExecutedStatus.getTaskBeginTime());return e.taskExecutedStatus.setWorkerTimePeriod([r,Number(process_1.default.hrtime.bigint())]),!0}catch(t){return!(t instanceof Error)||((0,task_control_center_listener_js_1.onTaskFailed)(e,t),hvigor_process_js_1.hvigorProcess.error(t,e.getTaskLog()),!1)}}