"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.normalWorker=exports.watchWorker=void 0;const cluster_1=__importDefault(require("cluster")),worker_threads_1=require("worker_threads"),noop_js_1=require("../../../../common/util/noop.js"),build_event_js_1=require("../../../common/daemon-protocol/build-event.js"),hvigor_daemon_log_js_1=require("../../../daemon/log/hvigor-daemon-log.js"),duration_event_js_1=require("../../../metrics/event/duration-event.js"),log_event_js_1=require("../../../metrics/event/log-event.js"),constant_js_1=require("../constant/constant.js"),log=hvigor_daemon_log_js_1.HvigorDaemonLogger.getLogger("daemon");class WorkerItem{constructor(e,r){this.worker=e,this.hasCustomTerminate=r}}const genPromiseAndTriggers=(e,r)=>{let t=noop_js_1.noop,o=noop_js_1.noop;const n=new Promise(((n,s)=>{t=t=>{e.taskExecutedStatus.setWorkerTimePeriod([r,Number(process.hrtime.bigint())]),s(t)},o=t=>{e.taskExecutedStatus.setWorkerTimePeriod([r,Number(process.hrtime.bigint())]),n(t)}}));return{reject:t,resolve:o,promise:n}};async function handleResponse(e,r,t,o,n,s){if(e.event!==constant_js_1.PoolConstant.WORK_DONE){if(e.event===constant_js_1.PoolConstant.WORK_ERROR){null==s||s.stop(duration_event_js_1.DurationEventState.FAILED),null==s||s.setLog(null==s?void 0:s.getName(),log_event_js_1.MetricLogType.ERROR),await n(e.returnVal);const a=e.error,i=`${r.getName()} ${o?"watch":"normal"} work[${t}] failed.`;throw log.debug(i),new Error(a||i)}throw new Error(`Unknown worker event: ${e}.`)}null==s||s.stop(duration_event_js_1.DurationEventState.SUCCESS),null==s||s.setLog(null==s?void 0:s.getName(),log_event_js_1.MetricLogType.INFO),await n(e.returnVal)}class WorkerCountManager{static allocateWorkerId(){return this.cnt++}static reset(){this.cnt=1}}WorkerCountManager.cnt=1;class WatchWorker{constructor(){this.workerMap=new Map,this.addListenersOnSessionManager()}getWorker(e){var r;return null===(r=this.workerMap.get(e))||void 0===r?void 0:r.worker}createWorker(e,r,t,o,n){const s=Number(process.hrtime.bigint()),a=new worker_threads_1.Worker(r,n),i=WorkerCountManager.allocateWorkerId();this.workerMap.set(i,new WorkerItem(a,t));const l=e.addSubDurationEvent(i.toString()).start();null==l||l.setTid(`Worker${i}`),cluster_1.default.isWorker&&process.send({type:build_event_js_1.WatchEvent.NEW_WATCH_WORKER,workerId:i});const{promise:_,resolve:u,reject:d}=genPromiseAndTriggers(e,s);return e.pendingPromises.add(_),a.on("message",(async r=>{if(r){if(!r.event)return r.type===build_event_js_1.WatchEvent.WATCH_COMPILE_RESULT||r.type===build_event_js_1.WatchEvent.WATCH_START||r.type===build_event_js_1.WatchEvent.WATCH_RESULT||r.type===build_event_js_1.WatchEvent.WATCH_LOG?(log.debug(`watch worker: send response to session manager. Response type: ${r.type}`),void(cluster_1.default.isWorker&&process.send({...r,workerId:i}))):r.type===build_event_js_1.WatchEvent.TERMINATE_WORKER?(log.debug("watch worker: worker is ready to be terminated."),void this.terminateWorker(r.content)):void d(new Error(`Unknown watch event: ${r}.`));try{await handleResponse(r,e,i,!0,o,l),u("succeed")}catch(e){d(e)}}else d(new Error("Undefined response."))})),a.on("error",(async r=>{log.error(`${e.getName()} watch work[${i}] failed.`),log.error(r),d(r)})),i.toString()}beforeTerminate(e){var r,t;(null===(r=this.workerMap.get(e))||void 0===r?void 0:r.hasCustomTerminate)?null===(t=this.workerMap.get(e))||void 0===t||t.worker.postMessage({type:build_event_js_1.WatchEvent.TERMINATE_WORKER,content:e}):this.terminateWorker(e)}terminateWorker(e){var r;null===(r=this.workerMap.get(e))||void 0===r||r.worker.terminate(),this.workerMap.delete(e),log.debug(`Server currently has ${this.workerMap.size} `+(this.workerMap.size>1?"watch-workers":"watch-worker"))}addListenersOnSessionManager(){cluster_1.default.isWorker&&cluster_1.default.worker.on("message",(e=>{var r;void 0!==e.workerId&&0!==e.workerId?e.type===build_event_js_1.WatchEvent.WATCH_COMPILE_DATA?(log.debug("watch worker: receive watch compile tata."),null===(r=this.getWorker(e.workerId))||void 0===r||r.postMessage(e.content)):e.type===build_event_js_1.WatchEvent.CLOSE_WATCH&&this.beforeTerminate(e.workerId):log.debug("watch worker: worker id should be larger than 0. Nothing will be sent to any worker thread.")}))}}class NormalWorker{constructor(){this.maxWorkerNum=constant_js_1.PoolConstant.MAX_POOL_NUM>1?constant_js_1.PoolConstant.MAX_POOL_NUM-1:1}createWorker(e,r,t,o,n){const s=Number(process.hrtime.bigint()),a=WorkerCountManager.allocateWorkerId(),{promise:i,resolve:l,reject:_}=genPromiseAndTriggers(e,s);return e.pendingPromises.add(i),NormalWorker.promiseMap.set(a,{resolve:l,reject:_}),NormalWorker.runningThreadCnt>=this.maxWorkerNum?(log.debug(`Creating worker failed since runningThreadCnt is not smaller than ${this.maxWorkerNum}.`),NormalWorker.workQueue.push({workerId:a,task:e,filename:r,callback:o,options:n})):(log.debug(`Creating worker with id ${a}.`),this.executeWorker(a,e,r,o,n)),a.toString()}reset(){NormalWorker.runningThreadCnt=0,NormalWorker.workQueue.length=0,NormalWorker.promiseMap.clear()}executeWorker(e,r,t,o,n){const s=new worker_threads_1.Worker(t,n);NormalWorker.runningThreadCnt++;const{resolve:a,reject:i}=NormalWorker.promiseMap.get(e);NormalWorker.promiseMap.delete(e);const l=r.addSubDurationEvent(e.toString()).start();null==l||l.setTid(`Worker${e}`),s.on("message",(async t=>{if(t)if(t.event)try{if(await handleResponse(t,r,e,!1,o,l),s.terminate(),NormalWorker.runningThreadCnt--,NormalWorker.workQueue.length){const e=NormalWorker.workQueue.shift();log.debug(`Normal worker queue is not empty. Create worker with id: ${e.workerId}.`),this.executeWorker(e.workerId,e.task,e.filename,e.callback,e.options)}a(!0)}catch(e){i(e)}else t.type!==build_event_js_1.WatchEvent.WATCH_COMPILE_RESULT&&t.type!==build_event_js_1.WatchEvent.WATCH_START&&t.type!==build_event_js_1.WatchEvent.WATCH_RESULT&&t.type!==build_event_js_1.WatchEvent.WATCH_LOG&&(t.type!==build_event_js_1.WatchEvent.TERMINATE_WORKER?i(new Error(`Unknown watch event: ${t}.`)):log.debug("Impossible response type in normal worker: TERMINATE_WORKER"));else i(new Error("Undefined response."))})),s.on("error",(async t=>{log.debug(`${r.getName()} normal work[${e}] failed.`),i(t)}))}}NormalWorker.runningThreadCnt=0,NormalWorker.workQueue=[],NormalWorker.promiseMap=new Map,exports.watchWorker=new WatchWorker,exports.normalWorker=new NormalWorker;