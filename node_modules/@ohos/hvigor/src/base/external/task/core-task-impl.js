"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.CoreTaskImpl=void 0;const noop_js_1=require("../../../common/util/noop.js"),class_type_const_js_1=require("../../common/options/class-type-const.js"),worker_delegator_js_1=require("../../internal/pool/worker-pool/worker-delegator.js"),task_execute_status_js_1=require("../../internal/task/core/task-execute-status.js"),task_pending_promises_js_1=require("../../internal/task/core/task-pending-promises.js"),task_path_util_js_1=require("../../internal/task/util/task-path-util.js"),hvigor_log_js_1=require("../../log/hvigor-log.js"),metric_factory_js_1=require("../../metrics/metric-factory.js"),class_identify_util_js_1=require("../../util/class-identify-util.js"),task_impl_js_1=require("../../vigor/task/impl/task-impl.js"),core_task_js_1=require("./core-task.js"),queue_js_1=require("../../../common/util/queue.js"),stack_js_1=require("../../../common/util/stack.js"),_log=hvigor_log_js_1.HvigorLogger.getLogger("hvigor-core-task");class CoreTaskImpl extends core_task_js_1.CoreTask{constructor(e,t){var s;super(),this.dependsTask=[],this.fn=noop_js_1.noop,this.afterRunFnQueue=new queue_js_1.Queue,this.beforeRunFnStack=new stack_js_1.Stack,this.node=e;const r={group:core_task_js_1.HvigorTaskGroupType.OTHER_TASK_GROUP,isEnabled:!0,...t};this.name=r.name,this.group=r.group,this.isEnabled=r.isEnabled,this.description=null!==(s=r.description)&&void 0!==s?s:"",this.path=CoreTaskImpl.createTaskPath(this.node,this.name),this.taskExecutedStatus=new task_execute_status_js_1.TaskExecuteStatus,this.pendingPromises=new task_pending_promises_js_1.TaskPendingPromises,this.durationEvent=metric_factory_js_1.MetricFactory.createDurationEvent(this.path,this.description,this.group),this.subDurationEventMap=new Map,this.workerDelegator=new worker_delegator_js_1.WorkerPoolDelegator,this.taskLog=hvigor_log_js_1.HvigorLogger.getLoggerWithDurationId("hvigor-core-task",this.durationEvent.getId()),this.durationEvent.setDetail(`create ${this.path} task`)}getWorkerPool(){return this.workerDelegator}async execute(){var e,t;null===(e=this.executeBeforeRun)||void 0===e||e.bind(this)();const s=this.getAction();await s.bind(this)(),null===(t=this.executeAfterRun)||void 0===t||t.bind(this)()}taskShouldDo(){return!0}onFailed(e){}setDependsOn(...e){return this.dependsTask=e,this}getDependsOn(){return this.dependsTask}addDependsOn(e){return this.dependsTask.push(e),this}dependsOn(e,t){let s,r;return s=e instanceof core_task_js_1.CoreTask?e.getName():e,r=void 0===t?this.node:"string"==typeof t?this.findTargetNode(t):t,void 0===r&&this.taskLog.errorMessageExit(`Failed to find the '${t}' node while setting the task dependencies in the ${this.node.getName()} module's task: ${this.name}.`),this.dependsTask.push(CoreTaskImpl.createTaskPath(r,s)),this}findTargetNode(e){let t=this.node.findModuleByName(e);return void 0===t&&this.isProject(e)&&(t=this.node.getProject()),t}isProject(e){return":"===e||e===this.node.getProject().getName()}getAction(){return this.fn}getNode(){return this.node}getName(){return this.name}getPath(){return this.path}getTaskLog(){return this.taskLog}getEnabled(){return this.isEnabled}setEnabled(e){return this.isEnabled=e,this}setDescription(e){return this.description=e,this}getDescription(){return this.description}getGroup(){return this.group}setGroup(e){return this.group=e,this}doNotTrackState(e){this.taskExecutedStatus.unTrackStateReason=e}addSubDurationEvent(e){const t=this.durationEvent.createSubEvent(this.durationEvent.getName(),this.durationEvent.getDescription());return this.subDurationEventMap.set(e,t),t}getSubDurationEvent(e){return this.subDurationEventMap.get(e)}static createTaskPath(e,t){let s="";return(0,class_identify_util_js_1.instanceOf)(e,class_type_const_js_1.ClassTypeConst.HVIGOR_PROJECT)||(s=e.getName(),""===s&&_log.errorMessageExit("Error module name,can not be empty string!")),(0,task_path_util_js_1.union)(s,t)}getHvigorTask(){return new task_impl_js_1.TaskImpl(this)}beforeRun(e){this.beforeRunFnStack.push(e)}afterRun(e){this.afterRunFnQueue.push(e)}getAfterRunQueue(){return this.afterRunFnQueue}getBeforeRunStack(){return this.beforeRunFnStack}executeBeforeRun(){for(;!this.beforeRunFnStack.isEmpty();){const e=this.beforeRunFnStack.pop();e&&e.bind(this)()}}executeAfterRun(){for(;this.afterRunFnQueue.size()>0;){const e=this.afterRunFnQueue.pop();e&&e.bind(this)()}}}exports.CoreTaskImpl=CoreTaskImpl;